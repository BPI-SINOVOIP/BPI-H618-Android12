// update.cpp : Defines the entry point for the console application.
//

#include "common.h"

__asm__(".symver memcpy ,memcpy@GLIBC_2.2.5");

#if 0
/* image header(128B) */
typedef struct image_header {
	u32 ih_magic;             /* Image Header Magic Number */
	u16 ih_hversion;          /* Image Header Version:     */
	u16 ih_pversion;          /* Image Payload Version:    */
	u16 ih_hchksum;           /* Image Header Checksum     */
	u16 ih_dchksum;           /* Image Data Checksum       */
	u32 ih_hsize;             /* Image Header Size         */
	u32 ih_psize;             /* Image Payload Size        */
	u32 ih_tsize;             /* Image TLV Size            */
	u32 ih_load;              /* Image Load Address        */
	u32 ih_ep;                /* Image Entry Point         */
	u32 ih_imgattr;           /* Image Attribute           */
	//    u32 ih_flag;              /* Image Flag                */
	u32 ih_nxtsecaddr;        /* Next Section Address      */
	u8  ih_name[16];          /* Image Name                */
	u32 ih_priv[18];          /* Image Private Data        */
		 /* Usage of Bootloader's Private Data */
		 /* ih_priv[0]: [7:0]-ota_flash_num,[31:8]-ota_size */
		 /* ih_priv[1]: [31:0]-ota_addr */
		 /* ih_priv[2]: [15:0]-img_max_size,[31:16]-img_xz_max_size */
		 /* ih_priv[3]: [31:0]-reserve */
		 /* ih_priv[4]: [31:0]-reserve */
		 /* ih_priv[5]: [31:0]-next_safety_bin_addr */
} image_header_t;
#endif

#if 0
#define VECTOR_TABLE_SIZE (0x240)
#else
#define VECTOR_TABLE_SIZE (0)
#endif

/******************************************************************************/
/*                              file head of Boot                             */
/******************************************************************************/
#define MAGIC_SIZE 8
typedef struct _Boot_file_head {
	__u32  jump_instruction;   /* one intruction jumping to real code */
	__u8   magic[MAGIC_SIZE];  /* ="eGON.BT0" */
	__u32  check_sum;          /* generated by PC */
	__u32  length;             /* generated by PC */
	__u32  pub_head_size;      /* the size of boot_file_head_t */
	__u8   pub_head_vsn[4];    /* the version of boot_file_head_t */
	__u32 ret_addr;           /* the return value */
	__u32  run_addr;           /* run addr */
	__u32  boot_cpu;           /* eGON version */
	__u8   platform[8];        /* platform information */
} boot_file_head_t;

void *script_file_decode(char *script_name);
int update_for_toc0(char *toc0_name);

//------------------------------------------------------------------------------------------------------------
//
// 函数说明
//
//
// 参数说明
//
//
// 返回值
//
//
// 其他
//    无
//
//------------------------------------------------------------------------------------------------------------
void Usage(void)
{
	printf("\n");
	printf("Usage:\n");
	printf("update_rtos_sboot <sboot file path> <para file path>\n\n");
}

int main(int argc, char *argv[])
{
	char   source_sboot_name[MAX_PATH];
	char   script_file_name[MAX_PATH];
	char   *script_buf = NULL;
	int    ret = -1;

	if (argc != 3) {
			Usage();
			return ret;
	}

	GetFullPath(source_sboot_name,  argv[1]);
	GetFullPath(script_file_name,   argv[2]);

	printf("\n");
	printf("sboot file Path=%s\n", source_sboot_name);
	printf("script file Path=%s\n", script_file_name);
	printf("\n");
	//初始化配置脚本
	script_buf = (char *)script_file_decode(script_file_name);
	if (!script_buf) {
		printf("update sboot error: unable to get script data\n");

		goto _err_out;
	}
	script_parser_init(script_buf);
	//读取原始toc0
	if (update_for_toc0(source_sboot_name)) {
		printf("script update sboot fail\n");

		goto _err_out;
	}
    //获取原始脚本长度
	printf("script update sboot ok\n");

	ret = 0;

_err_out:
	if (script_buf) {
		free(script_buf);
	}

	return ret;
}


int update_for_toc0(char *toc0_name)
{
	FILE *sboot_file = NULL;
	char *sboot_buf = NULL;
	int   length = 0;
	int   i, j;
	int   ret = -1;
	int   value[8];
	script_gpio_set_t   gpio_set[32];
	sbrom_toc0_head_info_t *toc0_head;
	sbrom_toc0_config_t *toc0_config;
	boot_file_head_t *boot_head;

	sboot_file = fopen(toc0_name, "rb+");
	if (sboot_file == NULL) {
		printf("update:unable to open toc0 file\n");
		goto _err_toc0_out;
	}
	fseek(sboot_file, 0, SEEK_END);
	length = ftell(sboot_file);
	fseek(sboot_file, 0, SEEK_SET);
	if (!length) {
		goto _err_toc0_out;
	}
	sboot_buf = (char *)malloc(length);
	if (!sboot_buf) {
		goto _err_toc0_out;
	}
	fread(sboot_buf, length, 1, sboot_file);
	rewind(sboot_file);

	boot_head = (boot_file_head_t *)(sboot_buf + VECTOR_TABLE_SIZE);
	if (strncmp((const char *)boot_head->magic, "TOC0.GLH", 8)) {
		printf("sboot boot head magic error: %s\n", boot_head->magic);
		goto _err_toc0_out;
	}

	toc0_head = (sbrom_toc0_head_info_t *)(sboot_buf + VECTOR_TABLE_SIZE + sizeof(boot_file_head_t));
	toc0_config = (sbrom_toc0_config_t *)(sboot_buf + VECTOR_TABLE_SIZE + sizeof(boot_file_head_t) + 0x80);

	toc0_head->magic    = TOC_MAIN_INFO_MAGIC;
	toc0_head->end      = TOC_MAIN_INFO_END;

	//检查toc0的数据结构是否完整
//    ret = check_file( (unsigned int *)sboot_buf, toc0_head->boot_head.length, TOC0_MAGIC );
//    if( ret != CHECK_IS_CORRECT )
//    {
//		goto _err_toc0_out;
//	}
	//取出数据进行修正,DRAM参数
	if (script_parser_sunkey_all("dram_para", (void *)toc0_config->dram_para)) {
		printf("script fetch dram para failed\n");
		// fixme, 20221008
		//goto _err_toc0_out;
	}
	//update power_mode para
	if (!script_parser_fetch("target", "power_mode", value)) {
		toc0_config->power_mode = value[0];
		printf("toc0_config->power_mode %d\n", toc0_config->power_mode);
	}
	//取出数据进行修正,UART参数
	if (!script_parser_fetch("uart_para", "uart_debug_port", value)) {
		toc0_config->uart_port = value[0];
	}
	if (!script_parser_mainkey_get_gpio_cfg("uart_para", gpio_set, 32)) {
		for (i = 0; i < 32; i++) {
			if (!gpio_set[i].port) {
				break;
			}
			toc0_config->uart_ctrl[i].port      = gpio_set[i].port;
			toc0_config->uart_ctrl[i].port_num  = gpio_set[i].port_num;
			toc0_config->uart_ctrl[i].mul_sel   = gpio_set[i].mul_sel;
			toc0_config->uart_ctrl[i].pull      = gpio_set[i].pull;
			toc0_config->uart_ctrl[i].drv_level = gpio_set[i].drv_level;
			toc0_config->uart_ctrl[i].data      = gpio_set[i].data;
		}
	}
	//取出数据进行修正,debugenable参数
	if (!script_parser_fetch("jtag_para", "jtag_enable", value)) {
		toc0_config->enable_jtag = value[0];
	}
	if (!script_parser_mainkey_get_gpio_cfg("jtag_para", gpio_set, 32)) {
		for (i = 0; i < 5; i++) {
			if (!gpio_set[i].port) {
				break;
			}
			toc0_config->jtag_gpio[i].port      = gpio_set[i].port;
			toc0_config->jtag_gpio[i].port_num  = gpio_set[i].port_num;
			toc0_config->jtag_gpio[i].mul_sel   = gpio_set[i].mul_sel;
			toc0_config->jtag_gpio[i].pull      = gpio_set[i].pull;
			toc0_config->jtag_gpio[i].drv_level = gpio_set[i].drv_level;
			toc0_config->jtag_gpio[i].data      = gpio_set[i].data;
		}
	}
	//取出数据进行修正，NAND参数
	if (!script_parser_mainkey_get_gpio_cfg("nand_para", gpio_set, 32)) {
		for (i = NAND0_GPIO_START, j = 0; i < NAND0_GPIO_START + NAND0_GPIO_MAX; i++, j++) {
			if (!gpio_set[j].port) {
				break;
			}
			toc0_config->storage_gpio[i].port      = gpio_set[j].port;
			toc0_config->storage_gpio[i].port_num  = gpio_set[j].port_num;
			toc0_config->storage_gpio[i].mul_sel   = gpio_set[j].mul_sel;
			toc0_config->storage_gpio[i].pull      = gpio_set[j].pull;
			toc0_config->storage_gpio[i].drv_level = gpio_set[j].drv_level;
			toc0_config->storage_gpio[i].data      = gpio_set[j].data;
		}
	}
	//取得卡0参赛
	if (!script_parser_mainkey_get_gpio_cfg("card0_boot_para", gpio_set, 32)) {
		for (i = CARD0_GPIO_START, j = 0; i < CARD0_GPIO_START + CARD0_GPIO_MAX; i++, j++) {
			if (!gpio_set[j].port) {
				break;
			}
			toc0_config->storage_gpio[i].port      = gpio_set[j].port;
			toc0_config->storage_gpio[i].port_num  = gpio_set[j].port_num;
			toc0_config->storage_gpio[i].mul_sel   = gpio_set[j].mul_sel;
			toc0_config->storage_gpio[i].pull      = gpio_set[j].pull;
			toc0_config->storage_gpio[i].drv_level = gpio_set[j].drv_level;
			toc0_config->storage_gpio[i].data      = gpio_set[j].data;
		}
	}
	//取得卡2参赛
	if (!script_parser_mainkey_get_gpio_cfg("card2_boot_para", gpio_set, 32)) {
		for (i = CARD2_GPIO_START, j = 0; i < CARD2_GPIO_START + CARD2_GPIO_MAX; i++, j++) {
			if (!gpio_set[j].port) {
				break;
			}
			toc0_config->storage_gpio[i].port      = gpio_set[j].port;
			toc0_config->storage_gpio[i].port_num  = gpio_set[j].port_num;
			toc0_config->storage_gpio[i].mul_sel   = gpio_set[j].mul_sel;
			toc0_config->storage_gpio[i].pull      = gpio_set[j].pull;
			toc0_config->storage_gpio[i].drv_level = gpio_set[j].drv_level;
			toc0_config->storage_gpio[i].data      = gpio_set[j].data;
		}
	}
	//取得spi0参数
	if (!script_parser_mainkey_get_gpio_cfg("spi0", gpio_set, 32)) {
		for (i = SPI0_GPIO_START, j = 0; i < SPI0_GPIO_START + SPI0_GPIO_MAX; i++, j++) {
			if (!gpio_set[j].port) {
				break;
			}
			toc0_config->storage_gpio[i].port      = gpio_set[j].port;
			toc0_config->storage_gpio[i].port_num  = gpio_set[j].port_num;
			toc0_config->storage_gpio[i].mul_sel   = gpio_set[j].mul_sel;
			toc0_config->storage_gpio[i].pull      = gpio_set[j].pull;
			toc0_config->storage_gpio[i].drv_level = gpio_set[j].drv_level;
			toc0_config->storage_gpio[i].data      = gpio_set[j].data;
		}
	}
	//取出secure参数
	if (!script_parser_fetch("secure", "dram_region_mbytes", value)) {
		toc0_config->secure_dram_mbytes = value[0];
	}
	if (!script_parser_fetch("secure", "drm_start_mbytes", value)) {
		toc0_config->drm_start_mbytes = value[0];
	}
	if (!script_parser_fetch("secure", "drm_size_mbytes", value)) {
		toc0_config->drm_size_mbytes = value[0];
	}
	if (!script_parser_fetch("cpu_logical_map", "cpu0", value)) {
		toc0_config->boot_cpu = value[0];
	}
	if (!script_parser_fetch("platform", "secure_without_OS", value)) {
		toc0_config->secure_without_OS = value[0];
	}
	if (!script_parser_fetch("platform", "debug_mode", value)) {
		toc0_config->debug_mode = value[0];
	} else {
		toc0_config->debug_mode = 8;
	}
	//取 A15 外挂电源使能引脚参数
	memset(&(toc0_config->a15_power_gpio), 0, sizeof(special_gpio_cfg));
	if (!script_parser_fetch("external_power", "a15_pwr_en", (int *)&gpio_set[0])) {
		toc0_config->a15_power_gpio.port = gpio_set[0].port;
		toc0_config->a15_power_gpio.port_num = gpio_set[0].port_num;
		toc0_config->a15_power_gpio.mul_sel = gpio_set[0].mul_sel;
		toc0_config->a15_power_gpio.data = gpio_set[0].data;
	}

	//数据修正完毕
	//重新计算校验和
	gen_check_sum_toc0((void *)(sboot_buf + VECTOR_TABLE_SIZE + sizeof(boot_file_head_t)));
	fwrite(sboot_buf, length, 1, sboot_file);

	ret = 0;

_err_toc0_out:
	if (sboot_buf) {
		free(sboot_buf);
	}
	if (sboot_file) {
		fclose(sboot_file);
	}

	return ret;
}

void *script_file_decode(char *script_file_name)
{
	FILE  *script_file;
	void  *script_buf = NULL;
	int    script_length;
	//读取原始脚本
	script_file = fopen(script_file_name, "rb");
	if (!script_file) {
		printf("update error:unable to open script file\n");
		return NULL;
	}
	//获取原始脚本长度
	fseek(script_file, 0, SEEK_END);
	script_length = ftell(script_file);
	if (!script_length) {
		fclose(script_file);
		printf("the length of script is zero\n");

		return NULL;
	}
	//读取原始脚本
	script_buf = (char *)malloc(script_length);
	if (!script_buf) {
		fclose(script_file);
		printf("unable malloc memory for script\n");

		return NULL;;
	}
	fseek(script_file, 0, SEEK_SET);
	fread(script_buf, script_length, 1, script_file);
	fclose(script_file);

	return script_buf;
}

